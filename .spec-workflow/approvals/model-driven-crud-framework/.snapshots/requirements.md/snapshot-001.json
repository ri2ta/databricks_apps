{
  "id": "snapshot_1766898676806_x5fyrchqv",
  "approvalId": "approval_1766898676797_fnr6labv1",
  "approvalTitle": "model-driven-crud-framework requirements",
  "version": 1,
  "timestamp": "2025-12-28T05:11:16.806Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\nDatabricks Apps 上で YAML によるエンティティ定義だけで CRUD UI を自動生成するモデル駆動フレームワークを提供する。Flask + HTMX + Tailwind + DaisyUI + Alpine.js を用い、業務ロジック実装に専念できる状態を作る。\n\n## Alignment with Product Vision\n- Declarative-first: UI は YAML 定義が源泉。ロジックは Flask 層へ分離。\n- Server-driven UI: HTMX 部分更新で軽量な UX を維持。\n- Extensible hooks: YAML からカスタムアクション・フィールド型を追加可能にする。\n- Secure/Observable: 入力バリデーション、ログ・メトリクスを標準化（Apps 内運用を想定）。\n\n## Requirements\n\n### Requirement 1: YAML 主導の CRUD 自動生成\n\n**User Story:** As an internal app developer, I want to define entities in YAML so that list/detail/form screens are generated without writing repetitive UI code.\n\n#### Acceptance Criteria\n1. WHEN an entity block is added to config/entities.yaml THEN the system SHALL render list, detail, and form views for that entity using shared templates without additional UI coding.\n2. WHEN list.columns are defined in YAML THEN the rendered grid SHALL honor label, order, and width settings for each column.\n3. WHEN form.sections/fields are defined THEN the form SHALL render field labels, types, and grouping per YAML, including DaisyUI/Tailwind classes for consistent styling.\n4. IF a required YAML attribute is missing or invalid THEN the system SHALL return a validation error indicating the entity name and the missing/invalid path.\n\n### Requirement 2: 汎用データグリッド（HTMX 部分更新）\n\n**User Story:** As a business user, I want an interactive list that supports paging and sorting so that I can browse records efficiently.\n\n#### Acceptance Criteria\n1. WHEN GET /<entity>/list is called THEN the response SHALL be an HTMX partial rendering the grid component with current rows and pagination controls.\n2. WHEN a column header is clicked with sort param THEN the grid SHALL re-render with the requested sort while preserving pagination context.\n3. WHEN a row is clicked THEN the system SHALL request and display the detail partial for that record in the designated hx-target area.\n4. IF the dataset exceeds one page THEN pagination controls SHALL request the next/previous page via HTMX without full page reload.\n\n### Requirement 3: 汎用フォームとカスタムアクション差し込み\n\n**User Story:** As a developer, I want forms to render from YAML and allow custom actions so that I can add domain logic without rebuilding UI.\n\n#### Acceptance Criteria\n1. WHEN a form is loaded for an entity THEN fields SHALL render according to YAML-defined field types (text, textarea, email, lookup, etc.) using shared field templates.\n2. WHEN the user submits the form via HTMX THEN the system SHALL process the data and return a partial response (success message or validation errors) targeting the main content area.\n3. WHEN YAML declares form.actions with endpoint references THEN buttons SHALL be generated that POST to those endpoints including the current form data.\n4. IF form validation fails THEN the response SHALL include field-level error messages without replacing the whole page.\n\n### Requirement 4: Lookup コンポーネントによる参照選択\n\n**User Story:** As a user, I want to search and select related records via a lookup modal so that I can link entities without typing IDs.\n\n#### Acceptance Criteria\n1. WHEN the lookup trigger is clicked THEN a modal overlay SHALL open with a search input wired to an HTMX endpoint for the lookup source.\n2. WHEN a lookup result is selected THEN the hidden field value SHALL update with the selected ID and the display text SHALL update without reloading the page.\n3. IF the lookup endpoint returns no results THEN the component SHALL show an empty state message within the modal.\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- Follow layers UI → Service → Repository → DB. Shared templates/components reside under templates/components and templates/partials.\n- Keep DB access centralized (db.py or repository layer) with clear interfaces for services.\n- Favor reusable HTMX partials and field sub-templates to avoid duplication.\n\n### Performance\n- HTMX responses (list/form/detail) P95 < 500ms within Databricks Apps under expected load.\n- Pagination and sorting requests SHALL avoid full page reloads and minimize payload size.\n\n### Security\n- No secrets in code; use Databricks Secret Scope/environment variables.\n- Validate all YAML inputs and form submissions; reject or sanitize unsafe values.\n- Return minimal error details to users while logging full diagnostics server-side.\n\n### Reliability\n- Gracefully handle missing/empty entity definitions with user-friendly messages and server logs.\n- Ensure DB connection pool initialization failures are logged and surfaced with fallback messaging.\n\n### Usability\n- Maintain consistent Tailwind + DaisyUI styling across grids/forms/lookups.\n- Use HTMX to keep focus/scroll position where possible after partial swaps.\n- Provide inline validation errors and success toasts/alerts via partials.\n",
  "fileStats": {
    "size": 5253,
    "lines": 77,
    "lastModified": "2025-12-28T05:11:14.464Z"
  },
  "comments": []
}